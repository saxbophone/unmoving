> These instructions are a modified version of the original toolchain-building
> instructions for PSn00bSDK
> (https://github.com/Lameguy64/PSn00bSDK/blob/ffa679d4d24b891cb59aba10946368f2ec00c391/toolchain.txt)
>
> Modified September 2021 by Joshua Saxby to describe the process for building the
> toolchain with support for the minimum set of C++ standard library headers
> required for freestanding implementations (https://en.cppreference.com/w/cpp/freestanding)
>
> NOTE that this is a very experimental process but has shown promising results so far

If you wish to build the toolchain yourself, beware that this process can get
pretty tedious unless you have a powerful enough computer with plenty of
threads to spare. A system with at least 4 to 8 total threads or more is
recommended. You may have better success building the toolchain in ArchLinux
especially if you want to build the most recent versions of GCC. Debian
Buster however, may have about the same chance of success in building as
using ArchLinux.

It is recommended to stick with GCC 7.4.0 and Binutils 2.31 as this is the
version PSn00bSDK is most tested with. Though generally, it doesn't hurt to
try out newer versions and has been known to work flawlessly without issue.

> You'll need a newer version of GCC than specified above if you want newer C++
> standard support such as for C++20.

These instructions are only for Linux, though they can be adapted for
building in Windows using MSys2 or Cygwin64. Beware that libgcc cannot
be built under Windows as the libgcc build process depends on symlinks
which is not supported by the operating system and is not wrapped by Msys2
and Cygwin64. The only workaround is to first build GCC in Linux then copy
the libgcc.a library from it to the Windows build.


Make sure the following packages are installed prior to building:
* make
* texinfo
* mpfr (development libs, if your distro offers it in a separate package)
* isl (development libs, if your distro offers it in a separate package)
* gmp (development libs, if your distro offers it in a separate package)
* mpc (development libs, if your distro offers it in a separate package)
* build-essential or build-essentials, if you don't have GCC installed yet.


Building binutils:

Binutils must be built first as GCC depends on binutils built for the same
target architecture. In this case, building binutils and GCC to target
mipsel-unknown-elf.

* Download binutils source files at ftp://ftp.gnu.org. Choose a version you
  wish to use with PSn00bSDK. The reference version that PSn00bSDK is tested
  with most is 2.31.
  
* Extract the contents of the archive, preferably in a directory named gcc.
  
* Create a directory named binutils-build inside the gcc directory. Do not
  create it inside the binutils directory with the source files.
  
* Enter the binutils-build directory and configure binutils from there
  with the following command line:

../binutils-<version>/configure --prefix=/usr/local/mipsel-unknown-elf \
--target=mipsel-unknown-elf --with-float=soft

Replace <version> with the version of binutils you wish to use. You may also
want to change the prefix argument to a path you prefer to have the toolchain
installed to (ie. somewhere within your home directory so you wouldn't need
root privileges to install).

* Run `make -j 4` to compile binutils (-j specifies how many simultaneous
  jobs to spawn at once, set it equal to the number of cores/threads your
  system has available to speed up compiling).
  
* Run `make install-strip` to install binutils to the path specified by the
  --prefix argument (root privileges are required if the prefix points to
  /usr/local).

Building newlib:

The default C++ standard library used with GCC can't build when building the
toolchain for PSn00bSDK. This would be fine because we generally build
freestanding for low-level systems like the PlayStation, however GCC won't even
install the minimum standard library headers required by the standard for
freestanding implementations if we don't build *a* C++ standard library.

A solution identified here (https://forum.osdev.org/viewtopic.php?f=8&t=23947)
is to build newlib for the target, and then build GCC with newlib. Newlib is a
small C/C++ standard library intended for use on embedded systems. We won't
actually install most of the built newlib with GCC, just the freestanding headers
but frustratingly, we still have to build the entirety of newlib to get the headers
in this way. These build instructions are simplified from these
(http://www.ifp.illinois.edu/~nakazato/tips/xgcc.html).

* Download newlib source with git: git://sourceware.org/git/newlib-cygwin.git

There is no need to do this in the gcc directory created earlier.
The version of newlib I tested this against was a bleeding-edge copy more
recent than v3.2.0. (commit: 8c8d3b7a9).

* Create a directory named newlib-build in the same directory you cloned the
  newlib source in.

* Enter the newlib-build directory and configure newlib from there with the
  following command:

../newlib-cygwin/configure --target=mipsel-unknown-elf \
--prefix=/usr/local/mipsel-unknown-elf --disable-newlib-supplied-syscalls

* Run make in the same manner you built binutils with.

* Run make install to install it.

NOTE: if you need superuser privileges to write to the installation directory
you might not be able to just run `sudo make install` to get around this.
Newlib's makefile doesn't like running as root and will refuse to do the install.

The workaround I used was to run `sudo su` to get a shell running as root, and
then to run `make install` from there.

You'll need to make sure that /usr/local/mipsel-unknown-elf/bin or wherever you're
building your toolchain to is in the root user's PATH otherwise the make install
command will not work.

Building gcc:

With binutils and newlib built it should be possible to build the GCC toolchain.
Since GCC is considerably larger than binutils, compile time is going to be much
longer so it's going to take a longer while to build this.

* Download gcc source files at ftp://ftp.gnu.org and choose the version you
  wish to use with PSn00bSDK. The reference version that PSn00bSDK is tested
  with most is 7.4.0.

* Extract it to the same gcc directory you extracted binutils in.

* Create a directory named gcc-build inside the gcc directory.

* Enter the gcc-build directory and configure gcc from there with the
  following command line:

../gcc-<version>/configure --disable-nls --disable-libada --disable-libssp \
--disable-libquadmath --disable-hosted-libstdcxx --target=mipsel-unknown-elf \
--prefix=/usr/local/mipsel-unknown-elf --with-float=soft \
--enable-languages=c,c++ --with-gnu-as --with-gnu-ld --with-newlib

Replace <version> with the version of gcc you downloaded. The prefix path
must match to what you've specified for binutils earlier, if you've decided
to use a different prefix path for binutils.

When building under Windows you must additionally specify --disable-libgcc,
as libgcc cannot be built under Windows as it needs symlinks which are not
supported by the operating system.

* Run make in the same manner you built binutils with.

* Run `make install-strip` to install gcc to the path specified by --prefix
  (root privileges are required if the prefix points to /usr/local).
  
* Add a path to the bin directory of the toolchain into your PATH environment
  variable by adding the following line in your .bashrc or .bash_profile file:
  
export PATH=$PATH:/usr/local/mipsel-unknown-elf/bin

Under Windows, you'll have to add the path to the PATH environment variable
through System Properties.


Note regarding C++ support:

C++ support in PSn00bSDK only goes as far as basic classes, namespaces and
the ability to dynamically create and delete class objects at any point of
the program. The required dependencies are supplied by libc of libpsn00b.

Standard C++ libraries are not implemented and likely never going to be
implemented due to bloat concerns that it may introduce. Besides, the official
SDK lacks full C++ support as well.

If you're trying to compile with C++ code and you get a linker error about
undefined vtables, try specifying --fno-rtti to the g++ command line.

> Note that the C++ support has been experimentally increased somewhat by this
> modified guide. The hosted standard C++ library and STL are still not included
> by intention, but most of the freestanding C++ headers can be #included with
> the exceptions of:
>
> * <cstdint> - declarations conflict with those of SDK's <sys/types.h>
> * <source_location> - file doesn't exist, probably new C++20 stuff not yet
>   implemented by the GCC or newlib version we tested against
> * <coroutine> - file doesn't exist, probably same reason as previous
> * <bit> - missing dependency: <ext/numeric_traits.h>
> * <atomic> - depends on <cstdint>
>
> It's important to clarify that simply being able to #include a header doesn't
> mean all the functionality in it is working. At the time of writing this guide
> both the spaceship operator (<=>) from <compare> and std::is_constant_evaluated()
> from <type_traits> were found to be working.

-----------------------------------------------------------------------------
Updating the ldscript (NO LONGER REQUIRED as PSn00bSDK now ships with its own
linker scripts, the section below is only kept for reference):

The following changes used to be required in order for basic C++ functionality
to work in older PSn00bSDK versions. The changes define the constructor and
deconstructor sections which are required for the relevant support functions
in PSn00bSDK's libc library to be linked properly for C++.

* Go to mipsel-unknown-elf/lib/ldscripts in the toolchain directory.
  
* Open elf32elmip.x in any text editor.

* Locate the .text definition (with the {} brackets) and add the following
  inside the bracket block:

__CTOR_LIST__ = .;
___CTOR_LIST__ = .;
LONG (((__CTOR_END__ - __CTOR_LIST__) / 4) - 2)
KEEP (*(SORT (.ctors.*)))
KEEP (*(.ctors))
LONG (0x00000000)
__CTOR_END__ = .;
. = ALIGN (0x10);

__DTOR_LIST__ = .;
___DTOR_LIST__ = .;
LONG (((__DTOR_END__ - __DTOR_LIST__) / 4) - 2)
KEEP (*(SORT (.dtors.*)))
KEEP (*(.dtors))
LONG (0x00000000)
__DTOR_END__ = .;
. = ALIGN (0x10);

* Save script changes.

Since there's no known way (at least to me -Lameguy64) to configure GCC such
that it uses the modified ldscript as the default, you must specify the
modified script during the linking stage of your projects with the -T
argument, when invoking mipsel-unknown-elf-ld.

Alternatively, you can make a copy of the ldscript file and modify it within
your project directory. This is especially useful if your project uses code
overlays.

